<?php
// Lightweight CSS dedupe/refactor script
// Usage: php dedupe-css.php input.css output.css
// Produces a deduplicated top-level selector file and preserves @media blocks (attempts to dedupe inside them too).

if ($argc < 3) {
    echo "Usage: php dedupe-css.php input.css output.css\n";
    exit(1);
}
$in = $argv[1];
$out = $argv[2];
if (!file_exists($in)) {
    echo "Input not found: $in\n";
    exit(1);
}
$css = file_get_contents($in);
// Remove comments to simplify parsing
$css = preg_replace('#/\*.*?\*/#s', "", $css);
$len = strlen($css);
$pos = 0;
$parts = [];

// Extract top-level tokens: either @-rules (like @media) or normal selector blocks
while ($pos < $len) {
    // skip whitespace
    if (preg_match('/\s+/A', $css, $m, 0, $pos)) {
        $pos += strlen($m[0]);
        continue;
    }
    if ($css[$pos] === '@') {
        // at-rule: capture until matching braces if present
        $start = $pos;
        // find first '{'
        $brace = strpos($css, '{', $pos);
        if ($brace === false) {
            // no block, capture until semicolon
            $semi = strpos($css, ';', $pos);
            $parts[] = trim(substr($css, $pos, $semi ? $semi-$pos+1 : null));
            $pos = $semi ? $semi+1 : $len;
            continue;
        }
        // scan to matching closing brace
        $depth = 0;
        $i = $brace;
        for (; $i < $len; $i++) {
            if ($css[$i] === '{') $depth++;
            elseif ($css[$i] === '}') {
                $depth--;
                if ($depth === 0) { $i++; break; }
            }
        }
        $parts[] = substr($css, $start, $i - $start);
        $pos = $i;
    } else {
        // selector block
        $start = $pos;
        $brace = strpos($css, '{', $pos);
        if ($brace === false) break;
        $depth = 0;
        $i = $brace;
        for (; $i < $len; $i++) {
            if ($css[$i] === '{') $depth++;
            elseif ($css[$i] === '}') {
                $depth--;
                if ($depth === 0) { $i++; break; }
            }
        }
        $parts[] = substr($css, $start, $i - $start);
        $pos = $i;
    }
}

// Helper to parse blocks (selector { rules }) into array selector => [prop=>val]
function parse_blocks($text) {
    $map = [];
    if (!preg_match_all('/([^\{]+)\{([^\}]*)\}/s', $text, $m)) return $map;
    foreach ($m[0] as $idx => $full) {
        $selector = trim($m[1][$idx]);
        $rules = trim($m[2][$idx]);
        // split selectors by comma and normalize
        $selList = array_map('trim', explode(',', $selector));
        // parse properties
        $props = [];
        $pairs = preg_split('/;\s*/', $rules, -1, PREG_SPLIT_NO_EMPTY);
        foreach ($pairs as $pair) {
            $kv = explode(':', $pair, 2);
            if (count($kv) < 2) continue;
            $key = trim($kv[0]);
            $val = trim($kv[1]);
            $props[$key] = $val; // last wins
        }
        foreach ($selList as $sel) {
            if (!isset($map[$sel])) $map[$sel] = [];
            // merge properties, last seen wins
            foreach ($props as $k => $v) $map[$sel][$k] = $v;
        }
    }
    return $map;
}

$out_parts = [];

foreach ($parts as $part) {
    $trim = ltrim($part);
    if (strpos($trim, '@media') === 0 || strpos($trim, '@supports') === 0) {
        // process inner content to dedupe inside media too
        if (preg_match('/^([^\{]+)\{(.*)\}$/s', $part, $mm)) {
            $atHeader = trim($mm[1]);
            $inner = $mm[2];
            $innerMap = parse_blocks($inner);
            $innerText = "";
            foreach ($innerMap as $sel => $props) {
                $innerText .= $sel . " {\n";
                foreach ($props as $k => $v) $innerText .= "    $k: $v;\n";
                $innerText .= "}\n\n";
            }
            $out_parts[] = $atHeader . "{\n" . $innerText . "}\n\n";
        } else {
            // fallback: keep as-is
            $out_parts[] = $part;
        }
    } elseif (strpos($trim, '@') === 0) {
        // other at-rule without block, keep
        $out_parts[] = $part;
    } else {
        // normal selector blocks; accumulate and dedupe all of them together
        // we'll parse at end - collect
        $out_parts[] = $part; // keep for now
    }
}

// Combine all non-media top-level blocks into one map to dedupe
$top_text = '';
foreach ($out_parts as $p) {
    $t = ltrim($p);
    if (strpos($t, '@media') === 0 || strpos($t, '@supports') === 0) continue;
    if (strpos($t, '@') === 0) continue;
    $top_text .= $p . "\n\n";
}
$topMap = parse_blocks($top_text);

// Build final output
$final = "/* Refactored/deduped CSS - generated by tools/dedupe-css.php */\n\n";
// Write top-level selectors first
foreach ($topMap as $sel => $props) {
    $final .= $sel . " {\n";
    foreach ($props as $k => $v) $final .= "    $k: $v;\n";
    $final .= "}\n\n";
}

// Append media/at-rule parts (they were processed into out_parts)
foreach ($out_parts as $p) {
    $t = ltrim($p);
    if (strpos($t, '@media') === 0 || strpos($t, '@supports') === 0) {
        $final .= $p . "\n\n";
    }
}

file_put_contents($out, $final);

echo "Wrote refactored CSS to $out\n";

